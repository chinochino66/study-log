**JOIN／INNER／LEFT** を一気に叩き込む。

---

# 0) メンタルモデル（超重要）

* **テーブル＝行の集合**。
* **主キー（PK）**は一意、**外部キー（FK）**が相手のPK（またはユニークキー）を指す。
* JOINは「条件を満たす行どうしを**行レベルで合体**」する操作。
* **一致が複数あれば行は**“掛け算”的に増える（＝**ファンアウト**）。

```
Users( PK: id )   1 ──── *  Orders( FK: user_id )
```

---

# 1) INNER JOIN（共通部分だけ）

## 定義

* 左右の表で **ON 条件が真**になった行だけを返す。
* どちらかに無ければ、その行は**出ない**（NULLも出ない）。

```sql
SELECT u.id, u.name, o.order_id, o.amount
FROM Users u
INNER JOIN Orders o
  ON o.user_id = u.id;
```

### 特徴・落とし穴

* **WHERE と ON の違いは基本的に無し**（INNERの範囲では）。
  例：`... INNER JOIN Orders o ON o.user_id = u.id AND o.amount > 0`
  と
  `... INNER JOIN Orders o ON o.user_id = u.id WHERE o.amount > 0`
  は同じ結果。
* **重複増殖**：1ユーザーに注文3件 ⇒ 結合後3行。集計時は意図せぬ二重計上に注意。
  → 必要なら**前集計** or `COUNT(DISTINCT ...)`。

---

# 2) LEFT JOIN（左は必ず残す）

## 定義

* 左表の行は**必ず残す**。右で一致が無いと、その行は**右側がNULLで残る**。

```sql
SELECT u.id, u.name, o.order_id
FROM Users u
LEFT JOIN Orders o
  ON o.user_id = u.id;
```

### 使いどころ

* 「**全ユーザー**を出しつつ、注文があれば付ける。無ければ**NULL**。」
* **ゼロ件検出（アンチ結合）**の土台：

  ```sql
  SELECT u.id
  FROM Users u
  LEFT JOIN Orders o ON o.user_id = u.id
  WHERE o.user_id IS NULL;  -- ←“注文なし”のユーザー
  ```

### 重大な落とし穴：**LEFTをINNERに潰すバグ**

* `LEFT JOIN` の右テーブル列に対する条件を **WHERE に書くと**
  NULL行が弾かれて**実質 INNER 化**する。
* 回避：**任意側（右側）に関する条件は ON に書く**。

```sql
-- 悪い例（NULLが落ちる→INNER化）
SELECT u.id
FROM Users u
LEFT JOIN Orders o ON o.user_id = u.id
WHERE o.amount > 0;   -- ← NULLは比較できず落ちる

-- 良い例（“右があるなら条件適用、無ければNULLで残す”）
SELECT u.id
FROM Users u
LEFT JOIN Orders o
  ON o.user_id = u.id
 AND o.amount > 0;     -- ← 条件はONへ
```

### NULLの扱い

* `NULL = NULL` は**真にならない**（Unknown）。
  等価結合に使う列がNULLだと原則一致しない。
  → その設計は見直すか、`COALESCE` などで明示処理。

---

# 3) 反結合（“無い”を取る）と準結合（“ある”かだけ）

## 反結合（Anti-Join）

* **LEFT JOIN ... IS NULL** 型
* **NOT EXISTS** 型（現場ではこちらが読みやすいことも）

```sql
-- A) LEFT ... IS NULL
SELECT v.customer_id, COUNT(*) AS count_no_trans
FROM Visits v
LEFT JOIN Transactions t ON t.visit_id = v.visit_id
WHERE t.visit_id IS NULL
GROUP BY v.customer_id;

-- B) NOT EXISTS
SELECT v.customer_id, COUNT(*) AS count_no_trans
FROM Visits v
WHERE NOT EXISTS (
  SELECT 1
  FROM Transactions t
  WHERE t.visit_id = v.visit_id
)
GROUP BY v.customer_id;
```

> 多くのDBで最終的に**Anti-Join**として最適化。可読性で選ぶ。

## 準結合（Semi-Join：「あるかだけ」）

* **EXISTS** / **IN** を使い、「相手に1件でもあればOK」
  （右側列は出さない／重複しない）

```sql
SELECT u.id
FROM Users u
WHERE EXISTS (SELECT 1 FROM Orders o WHERE o.user_id = u.id);
```

---

# 4) 実務の設計 & 集計での事故防止

### 1) 前集計でファンアウト防止

```sql
-- 注文額をユーザー別に先に集約
WITH spend AS (
  SELECT o.user_id, SUM(o.amount) AS total_amount
  FROM Orders o
  GROUP BY o.user_id
)
SELECT u.id, COALESCE(s.total_amount, 0) AS total_amount
FROM Users u
LEFT JOIN spend s ON s.user_id = u.id;
```

### 2) COUNTとNULL

* `COUNT(*)` は行を数える（NULLでも1）。
* `COUNT(col)` は **colがNULLだと数えない**。
* 「取引なしの訪問数」なら、**WHEREで“取引なし行”に絞ってから `COUNT(*)`** が正解。

### 3) `USING` 構文（同名列の等値結合の糖衣）

```sql
SELECT *
FROM Orders
JOIN Users USING (user_id);  -- ON Orders.user_id = Users.user_id と同義
```

> 便利だが、**結合列名が1つに“吸収”** される仕様を把握しておく。

### 4) NATURAL JOIN は避ける

* 同名列を自動結合→**事故の温床**。明示的に `ON` / `USING` を使う。

### 5) CROSS JOIN（デカルト積）

* ON無しJOINや `CROSS JOIN` は全組合せ。**ほぼ使わない**（爆発的に増える）。

---

# 5) 複数JOINの設計指針

* **必須テーブル＝INNER**、**任意（無くても出したい）＝LEFT** を基本線に。
* 任意側のフィルタは **ON に書く**（WHEREに書くとLEFTが死ぬ）。
* 複数LEFTを連ねるとき、**どの段で“任意化”したか**を常に意識。

```sql
SELECT u.id, last.order_id, pay.paid_at
FROM Users u
LEFT JOIN LATERAL (  -- DB次第。無ければ前集計CTEで代替
  SELECT o.order_id, o.ordered_at
  FROM Orders o
  WHERE o.user_id = u.id
  ORDER BY o.ordered_at DESC
  LIMIT 1
) last ON TRUE
LEFT JOIN Payments pay
  ON pay.order_id = last.order_id
 AND pay.status = 'captured'; -- ← 任意側条件はON
```

---

# 6) 実行計画の超入門（パフォーマンス感覚）

* **Nested Loop**：片方少量×もう片方に**索引**（Index）→強い。
* **Hash Join**：大きめ同士でも有効。結合キーをハッシュ化。
* **Merge Join**：両側がソート済み/索引順なら効く。

現場の鉄則：

* 結合キー（例：`Transactions.visit_id`）に **インデックス**。
* 反結合系は `NOT EXISTS` / `LEFT ... IS NULL` を適切に。
* **前集計**してからJOIN（ファンアウト防止）。

---

# 8) 速見表（決め手）

* **共通だけ** ⇒ `INNER JOIN`
* **左を必ず残す** ⇒ `LEFT JOIN`
* **右条件でLEFTが死ぬ** ⇒ 条件を **ON に移す**
* **“無い”を数える** ⇒ `LEFT ... IS NULL` か `NOT EXISTS`（反結合）
* **ダブりで二重計上しそう** ⇒ **前集計** or `COUNT(DISTINCT ...)`

---

# ファンアウト（fan-out）とは

**JOINで“1行が複数行に増える現象”**。
左表の1行に対し、右表で一致する行が`k`件あれば、結合後は**その1行がk倍に増殖**する。

* 数式イメージ：結果行数 = Σ（左側の各行について、ON条件に合致した右側行数）
* 最悪ケース：**CROSS JOIN**（全組合せ）＝ |A|×|B|
* 危険なのは **多対多（M:N）** のJOIN。桁違いに増える → 集計が狂う／遅くなる

## ファンアウトを“防ぐ／扱う”鉄則

1. **前集計して粒度をそろえる**（グループ化→1行に潰してからJOIN）
2. **COUNT(DISTINCT …)** や **SUM(DISTINCT …)** を使う（必要な単位を明示）
3. 「存在だけ見たい」→ **EXISTS（準結合）**、「無いものを探す」→ **NOT EXISTS／LEFT…IS NULL（反結合）**
4. 結合キーが本当に**一意**か確認（PK/UKで担保）

---

# INNER JOINでの“重複増殖”と集計の正しい型

> 「1ユーザーに注文3件 ⇒ 結合後3行」
> これは**正しい**動作。**“ユーザー×注文”の行**を作る操作だから。

* **件数を数えたいだけ**なら：

  ```sql
  -- ユーザーごとの注文件数
  SELECT u.id, COUNT(*) AS order_cnt
  FROM Users u
  JOIN Orders o ON o.user_id = u.id
  GROUP BY u.id;
  ```

  これは「ユーザー×注文 行」を数えるのでOK。

* ただし、さらに `OrderItems` のような明細までJOINすると**ファンアウト**で**注文件数が過大計上**される：

  ```sql
  -- ❌ NG例：注文に明細をJOINしてから数えると、明細件数ぶん増える
  SELECT u.id, COUNT(o.order_id) AS order_cnt
  FROM Users u
  JOIN Orders o      ON o.user_id = u.id
  JOIN OrderItems oi ON oi.order_id = o.order_id
  GROUP BY u.id;
  ```

  **対策1：COUNT(DISTINCT o.order_id)**

  ```sql
  -- ✅ 同じ目的を “注文IDのユニーク数” で数える
  SELECT u.id, COUNT(DISTINCT o.order_id) AS order_cnt
  FROM Users u
  JOIN Orders o      ON o.user_id = u.id
  JOIN OrderItems oi ON oi.order_id = o.order_id
  GROUP BY u.id;
  ```

  **対策2：前集計してからJOIN**

  ```sql
  WITH per_order AS (
    SELECT o.order_id, o.user_id
    FROM Orders o
    -- ここで1注文=1行に確定
  )
  SELECT u.id, COUNT(p.order_id) AS order_cnt
  FROM Users u
  JOIN per_order p ON p.user_id = u.id
  GROUP BY u.id;
  ```

> まとめ：**「何を数えるか（粒度）」を先に決めて、それに合わせて前集計 or DISTINCT**。これでファンアウト由来の二重計上を防げる。

---

# LEFT JOINの“左／右”とWHEREの落とし穴

```sql
SELECT u.id
FROM Users u
LEFT JOIN Orders o ON o.user_id = u.id;
```

* この場合の**左表は Users**、**右表は Orders**。
  「`LEFT JOIN Orders`」は**“左側に書いた表（Users）を必ず残す”**の意味。
* **ON条件**は「結び付けの条件」。一致が無いときは**右側列がNULL**で行を残す。

> Q：「残るのは `o.user_id = u.id` という認識で合ってる？」
> 違う。**残るのは Users の全行**（左表）。`o.user_id = u.id` は「結び付け条件」で、合致すれば右列が埋まり、合致しなければ右列がNULLになる。

## “LEFTがINNERに化ける”典型バグ

```sql
-- ❌ NG：WHEREに右表列条件を書くと、NULLが弾かれてLEFTの意味が消える
SELECT u.id
FROM Users u
LEFT JOIN Orders o ON o.user_id = u.id
WHERE o.amount > 0;   -- ← 合致無しの行は o.amount が NULL → 比較不可で落ちる
```

**正解：右表の条件はONに寄せる**

```sql
-- ✅ “合致があるならこの条件を満たすものだけ結ぶ。無ければNULLで残す”
SELECT u.id
FROM Users u
LEFT JOIN Orders o
  ON o.user_id = u.id
 AND o.amount  > 0;
```

> ここで `o.amount` は**右表列**。だからWHEREに置くと**NULL行が除外**されてLEFTの効果が失われ、“実質INNER”になる。

---

# 反結合（Anti-Join）と準結合（Semi-Join）詳細

## 反結合（Anti-Join）＝「**相手に存在しない**ものを出す」

代表2パターン（結果は等価になることが多い）：

**A) LEFT … IS NULL**

```sql
-- 取引のない訪問を数える（1581の核）
SELECT v.customer_id, COUNT(*) AS count_no_trans
FROM Visits v
LEFT JOIN Transactions t ON t.visit_id = v.visit_id
WHERE t.visit_id IS NULL
GROUP BY v.customer_id;
```

**B) NOT EXISTS**

```sql
SELECT v.customer_id, COUNT(*) AS count_no_trans
FROM Visits v
WHERE NOT EXISTS (
  SELECT 1
  FROM Transactions t
  WHERE t.visit_id = v.visit_id
)
GROUP BY v.customer_id;
```

* 思考法：**「相手側に1件も無い」**を条件化する。
* 実装上の違い：多くのDBで**Anti-Join最適化**され、性能は拮抗。可読性で選ぶ。

## 準結合（Semi-Join）＝「**相手に1件でもあれば**出す（相手の列は持ってこない）」

**EXISTS**

```sql
-- 注文が1件でもあるユーザー
SELECT u.id
FROM Users u
WHERE EXISTS (
  SELECT 1
  FROM Orders o
  WHERE o.user_id = u.id
);
```

**IN**（等価キーに限れば同旨）

```sql
SELECT u.id
FROM Users u
WHERE u.id IN (SELECT o.user_id FROM Orders o);
```

* ポイント：**右側の件数分だけ増やさない**（＝ファンアウトしない）。
  「あるかどうか」だけを判定したいときは、**JOINよりEXISTS/INが安全**。

---

# 仕上げの型（覚えておけば事故らない）

* 粒度ズレで二重計上しそう→ **前集計** or **COUNT(DISTINCT …)**
* 「あるかだけ」→ **EXISTS**（準結合）
* 「ないもの」→ **NOT EXISTS** or **LEFT … IS NULL**（反結合）
* LEFTの右表条件は**ONに寄せる**（WHEREに置くとLEFTが死ぬ）
* 多対多JOINは**ファンアウト警戒**（設計とインデックスを見直す）
