# 今日の到達目標

* `SELECT` と `WHERE` の基本句を **ミスなく**使える
* `NULL`・`LIKE`・`BETWEEN`・`IN/NOT IN` を説明できる
* Titanicの単一表で **サンプルクエリ5本**を動かし、各1～2行コメントを付す
* LeetCode **5問**を回答（SELECT/WHERE系）

---

# 0. 準備

### DuckDBを使う

* **インストール**：ターミナルでもいいけど、今回はノートブック内で

---

### 手順（ノートブック内で）

①DuckDBをインストール

```python
# 1) ノートのカーネルに対してインストール
%pip install -U duckdb

# 2) 念のため、同じカーネルでインストールできているかを確認
import sys
print("Python:", sys.executable)
import duckdb
print("duckdb:", duckdb.__version__)
```

②前処理に必要なセルだけ上から実行（インポート→CSV読込→欠損補完・変換→df_clean 作成）。

③保存＋絶対パス表示（これだけ実行）

```python
from pathlib import Path
df_clean.to_csv("cleaned_titanic.csv", index=False)
print("saved to:", Path("cleaned_titanic.csv").resolve())
```

④すぐDuckDBに取り込む

```python
import duckdb
con = duckdb.connect()
con.execute("""
    CREATE TABLE passengers AS
    SELECT * FROM read_csv_auto('ここに絶対パスを入れる', header=true);
""")
con.execute("SELECT COUNT(*) AS n FROM passengers;").df()
```

### カーネルって何？

Jupyter Notebookを使うとき、実は「ノートの裏側でPythonを動かしているエンジン」がいる。それを **カーネル（Kernel）** と呼ぶ。

イメージすると──

* **ノートブック**：操作画面・ノートの紙みたいなもの
* **カーネル**：実際にコードを実行するエンジン（頭脳）

セルに `print("hello")` と書いて実行すると、そのコードはカーネルに送られ、カーネルが処理して結果を返している。

---

### 「カーネル再起動」が必要になるタイミング

* 新しいライブラリを入れたとき → 既に動いているカーネルにはその情報が読み込まれていない
* 実行の流れがグチャグチャになったとき → 変数や設定が残っていてエラーになる

このとき「カーネルを再起動」すると、真っさらな状態のPythonが立ち上がるから、環境が整理される。

---

💡 だから、今日のケースでは

1. `%pip install duckdb` で入れた
2. もしすぐ使えなかったら → **カーネル再起動**
3. もう一度 `import duckdb` でOK

---

ここまでで「DuckDBを使う準備」は完了。

---

まず列名を確認
※Jupyterでは、DuckDBのSQLは con.execute("...") で実行する。

```python
# テーブル定義（列名・型）を確認
con.execute("PRAGMA table_info('passengers');").df()
```

# 1. 20分で基礎の“型”を叩き込む

* 行の抽出：`WHERE 条件`（**行**を削る）
* 範囲：`BETWEEN a AND b`（両端含む）
* 集合：`IN (...)` / `NOT IN (...)`
* 欠損：`IS NULL` / `IS NOT NULL`（※`= NULL` は**誤り**）
* 件数：`COUNT(*)` は全件、`COUNT(col)` は `NULL` を数えない
* 順序＆上位：`ORDER BY ...` + `LIMIT n`

---

# 2. 写経するサンプル5（Titanic）

**各クエリに “意図コメント” を1〜2行で書く。コピペ後に必ず自分の言葉で要約する。**

**Q1. 最高齢の生存者トップ5**

```sql
con.execute("""
  SELECT Age, Pclass, Fare, Sex_female, HasCabin
  FROM passengers
  WHERE Survived = 1 AND Age IS NOT NULL　# Survived 列は 0=死亡 / 1=生存 の2値。
  ORDER BY Age DESC
  LIMIT 5;
""").df()
```
クエリの WHERE Survived = 1 は、「生存者だけに絞る（=死亡者を除外）」という意味.


**Q2. 年齢欠損の件数と比率**

```sql
SELECT 
  SUM(CASE WHEN Age IS NULL THEN 1 ELSE 0 END) AS null_age,
  COUNT(*) AS total,
  1.0 * SUM(CASE WHEN Age IS NULL THEN 1 ELSE 0 END) / COUNT(*) AS ratio
FROM passengers;
```
結果、**ratio=0.0**になるのは正しい。理由はさっき前処理で`Age` を **中央値で埋めた**から、このテーブルにはもう `Age IS NULL` が残っていない。

### いまのSQLを分解

* `SUM(CASE WHEN Age IS NULL THEN 1 ELSE 0 END)`
  → 条件に合う行を1カウント、合わない行は0。合計で「NULL件数」になる。
* `COUNT(*)` → 全行数（NULLも含む）。
* `1.0 * … / …` → 片方を**小数型**にして「整数割りの切り捨て」を防ぐ（常に実数の比率にする）。

**次の課題（Q2′）**

「Cabin記録がない行の件数と比率」を求める。

```python
con.execute("""
  SELECT 
    SUM(CASE WHEN HasCabin = 0 THEN 1 ELSE 0 END) AS no_cabin_cnt,
    COUNT(*) AS total,
    1.0 * SUM(CASE WHEN HasCabin = 0 THEN 1 ELSE 0 END) / COUNT(*) AS ratio
  FROM passengers;
""").df()
```

### HasCabinって何？

前処理で作った**フラグ列**。

```python
df["HasCabin"] = df["Cabin"].notna().astype(int)
```

* **1**：Cabinに“記録がある”（欠損じゃない）
* **0**：Cabinが欠損（記録なし）

### `CASE WHEN HasCabin = 0 THEN 1 ELSE 0 END` の意味

SQL版の「条件式」。

* 条件が**真**（HasCabin=0）なら **1** を返す
* それ以外は **0** を返す
  → これを `SUM(...)` すれば、「HasCabin=0 の行の件数」になる。
  → `AVG(...)` にすれば、「HasCabin=0 の割合」になる。

**Q3′（生存率を出してみる）**

同じ条件（運賃20–50 & 港がSかC）で、生存率を出す。

```python
con.execute("""
  SELECT AVG(CASE WHEN Survived=1 THEN 1 ELSE 0 END) AS survival_rate
  FROM passengers
  WHERE Fare BETWEEN 20 AND 50
    AND (Embarked_S=1 OR Embarked_C=1);
""").df()
```

【コード解説】
```python
con.execute("""
```

* **Jupyter→DuckDBへの送信開始**。この三連クォート内がSQL本文。

```sql
  SELECT AVG(CASE WHEN Survived=1 THEN 1 ELSE 0 END) AS survival_rate
```

* **SELECT**：出力する列（今回は1列だけ）。
* **CASE WHEN Survived=1**：生存なら1、そうでなければ0を返す“条件式”。
* **AVG(...)**：その平均＝**1の割合**＝**生存率**になる。
* **AS survival_rate**：列名を `survival_rate` にする（別名）。

```sql
  FROM passengers
```

* どのテーブルから取るか。今はDuckDBに取り込んだ `passengers`。

```sql
  WHERE Fare BETWEEN 20 AND 50
```

* **フィルタ**：運賃が20以上**かつ**50以下（`BETWEEN`は両端を含む）。

```sql
    AND (Embarked_S=1 OR Embarked_C=1);
```

* さらに**乗船港フィルタ**：one-hot列で **S か C のどちらか**に乗った人だけに限定。
  括弧は **OR を束ねる**ため（ANDより先に評価してほしいから）。

```python
""").df()
```

* SQLの実行を終了して、**結果をDataFrameで受け取る**。

---

 **Q4：男女件数を数える**

```python
con.execute("""
```

* ここからSQL本文。

```sql
  SELECT 
    SUM(CASE WHEN Sex_female=1 THEN 1 ELSE 0 END) AS female_cnt,
```

* `Sex_female=1`（女性）の行だけ **1 を足す**→合計で女性人数。
* `AS female_cnt` は列名。

```sql
    SUM(CASE WHEN Sex_female=0 THEN 1 ELSE 0 END) AS male_cnt
```

* `Sex_female=0`（男性）の行だけ **1 を足す**→合計で男性人数。

```sql
  FROM passengers;
```

* データ元テーブル。

```python
""").df()
```

* 実行して結果をDataFrameで受け取る。

---

### ここまでの流れ（復習）

* **Q1**: `WHERE Survived=1 AND Age IS NOT NULL` → 生存者の最高齢を確認（80歳）
* **Q2′**: `HasCabin=0` の比率 → Cabin欠損率 ≈ 77%
* **Q3/Q3′**: `BETWEEN`＋港フィルタ → 運賃20–50＆S/Cの生存率 ≈ 42%
* **Q4**: `SUM(CASE WHEN ... )` で条件人数カウント → 女性314 / 男性577

---

**次のQ5（最後のサンプル）**

**式をSELECTとWHERE両方で使う**練習。
家族サイズ = `SibSp + Parch + 1` を作って、5人以上の家族を抽出する。

コードを1行ずつ解説。

```python
con.execute("""
```

* SQL本文の開始。

```sql
  SELECT (SibSp + Parch + 1) AS family_size,
         Fare, Survived
```

* **SELECT句**：`SibSp + Parch + 1` を計算して `family_size` と名付ける。
* ついでに運賃と生存フラグも表示。

```sql
  FROM passengers
```

* 元テーブル。

```sql
  WHERE (SibSp + Parch + 1) >= 5
```

* **WHERE句**でも同じ式を使って、家族サイズが5人以上の行を抽出。

```sql
  ORDER BY family_size DESC, Fare DESC;
```

* 家族サイズの大きい順 → その中で運賃が高い順に並べる。

```python
""").df()
```

* 実行＆DataFrameで表示。

---

# 4. LeetCode「20問」（SELECT/WHERE系）
done
