# 今日の到達目標

* `SELECT` と `WHERE` の基本句を **ミスなく**使える
* `NULL`・`LIKE`・`BETWEEN`・`IN/NOT IN` を説明できる
* Titanicの単一表で **サンプルクエリ5本**を動かし、各1～2行コメントを付す
* LeetCode **5問**を回答（SELECT/WHERE系）

---

# 0. 準備

### DuckDBを使う

* **インストール**：ターミナルでもいいけど、今回はノートブック内で

---

### 手順（ノートブック内で）

①DuckDBをインストール

```python
# 1) ノートのカーネルに対してインストール
%pip install -U duckdb

# 2) 念のため、同じカーネルでインストールできているかを確認
import sys
print("Python:", sys.executable)
import duckdb
print("duckdb:", duckdb.__version__)
```

②前処理に必要なセルだけ上から実行（インポート→CSV読込→欠損補完・変換→df_clean 作成）。

③保存＋絶対パス表示（これだけ実行）

```python
from pathlib import Path
df_clean.to_csv("cleaned_titanic.csv", index=False)
print("saved to:", Path("cleaned_titanic.csv").resolve())
```

④すぐDuckDBに取り込む

```python
import duckdb
con = duckdb.connect()
con.execute("""
    CREATE TABLE passengers AS
    SELECT * FROM read_csv_auto('ここに絶対パスを入れる', header=true);
""")
con.execute("SELECT COUNT(*) AS n FROM passengers;").df()
```

### カーネルって何？

Jupyter Notebookを使うとき、実は「ノートの裏側でPythonを動かしているエンジン」がいる。それを **カーネル（Kernel）** と呼ぶ。

イメージすると──

* **ノートブック**：操作画面・ノートの紙みたいなもの
* **カーネル**：実際にコードを実行するエンジン（頭脳）

セルに `print("hello")` と書いて実行すると、そのコードはカーネルに送られ、カーネルが処理して結果を返している。

---

### 「カーネル再起動」が必要になるタイミング

* 新しいライブラリを入れたとき → 既に動いているカーネルにはその情報が読み込まれていない
* 実行の流れがグチャグチャになったとき → 変数や設定が残っていてエラーになる

このとき「カーネルを再起動」すると、真っさらな状態のPythonが立ち上がるから、環境が整理される。

---

💡 だから、今日のケースでは

1. `%pip install duckdb` で入れた
2. もしすぐ使えなかったら → **カーネル再起動**
3. もう一度 `import duckdb` でOK

---

ここまでで「DuckDBを使う準備」は完了。

---

まず列名を確認
※Jupyterでは、DuckDBのSQLは con.execute("...") で実行する。

```python
# テーブル定義（列名・型）を確認
con.execute("PRAGMA table_info('passengers');").df()
```

# 1. 20分で基礎の“型”を叩き込む

* 行の抽出：`WHERE 条件`（**行**を削る）
* 文字列あいまい：`LIKE '%Miss.%'`（`_`は1文字、`%`は0文字以上）
* 範囲：`BETWEEN a AND b`（両端含む）
* 集合：`IN (...)` / `NOT IN (...)`
* 欠損：`IS NULL` / `IS NOT NULL`（※`= NULL` は**誤り**）
* 件数：`COUNT(*)` は全件、`COUNT(col)` は `NULL` を数えない
* 順序＆上位：`ORDER BY ...` + `LIMIT n`

---

# 2. 写経するサンプル5（Titanic）

**各クエリに “意図コメント” を1〜2行で書く。コピペ後に必ず自分の言葉で要約する。**

**Q1. 最高齢の生存者トップ5**

```sql
con.execute("""
  SELECT Age, Pclass, Fare, Sex_female, HasCabin
  FROM passengers
  WHERE Survived = 1 AND Age IS NOT NULL　# Survived 列は 0=死亡 / 1=生存 の2値。
  ORDER BY Age DESC
  LIMIT 5;
""").df()
```
クエリの WHERE Survived = 1 は、「生存者だけに絞る（=死亡者を除外）」という意味.


**Q2. 年齢欠損の件数と比率**

```sql
SELECT 
  SUM(CASE WHEN Age IS NULL THEN 1 ELSE 0 END) AS null_age,
  COUNT(*) AS total,
  1.0 * SUM(CASE WHEN Age IS NULL THEN 1 ELSE 0 END) / COUNT(*) AS ratio
FROM passengers;
```
結果、**ratio=0.0**になるのは正しい。理由はさっき前処理で`Age` を **中央値で埋めた**から、このテーブルにはもう `Age IS NULL` が残っていない。

### いまのSQLを分解

* `SUM(CASE WHEN Age IS NULL THEN 1 ELSE 0 END)`
  → 条件に合う行を1カウント、合わない行は0。合計で「NULL件数」になる。
* `COUNT(*)` → 全行数（NULLも含む）。
* `1.0 * … / …` → 片方を**小数型**にして「整数割りの切り捨て」を防ぐ（常に実数の比率にする）。

### 次の課題（Q2′）

「Cabin記録がない行の件数と比率」を求める。

```python
con.execute("""
  SELECT 
    SUM(CASE WHEN HasCabin = 0 THEN 1 ELSE 0 END) AS no_cabin_cnt,
    COUNT(*) AS total,
    1.0 * SUM(CASE WHEN HasCabin = 0 THEN 1 ELSE 0 END) / COUNT(*) AS ratio
  FROM passengers;
""").df()
```

### HasCabinって何？

前処理で作った**フラグ列**。

```python
df["HasCabin"] = df["Cabin"].notna().astype(int)
```

* **1**：Cabinに“記録がある”（欠損じゃない）
* **0**：Cabinが欠損（記録なし）

### `CASE WHEN HasCabin = 0 THEN 1 ELSE 0 END` の意味

SQL版の「条件式」。

* 条件が**真**（HasCabin=0）なら **1** を返す
* それ以外は **0** を返す
  → これを `SUM(...)` すれば、「HasCabin=0 の行の件数」になる。
  → `AVG(...)` にすれば、「HasCabin=0 の割合」になる。〇

## Q3′（生存率を出してみる）

同じ条件（運賃20–50 & 港がSかC）で、生存率を出す。

```python
con.execute("""
  SELECT AVG(CASE WHEN Survived=1 THEN 1 ELSE 0 END) AS survival_rate
  FROM passengers
  WHERE Fare BETWEEN 20 AND 50
    AND (Embarked_S=1 OR Embarked_C=1);
""").df()
```

**Q3. 運賃レンジ × 乗船港フィルタ**

```sql
con.execute("""
  SELECT Fare,
         CASE WHEN Embarked_S=1 THEN 'S'
              WHEN Embarked_C=1 THEN 'C'
              WHEN Embarked_Q=1 THEN 'Q'
              ELSE 'UNK' END AS Embarked_lbl,
         Survived
  FROM passengers
  WHERE Fare BETWEEN 20 AND 50
    AND (Embarked_S=1 OR Embarked_C=1)
  LIMIT 10;
""").df()
```

> ねらい：`BETWEEN` と `IN` の並用。範囲指定の感覚を得る。

**Q4. 称号抽出（LIKE）**

```sql
SELECT
  SUM(CASE WHEN Name LIKE '% Miss.%' THEN 1 ELSE 0 END) AS miss_cnt,
  SUM(CASE WHEN Name LIKE '% Mrs.%' THEN 1 ELSE 0 END)  AS mrs_cnt
FROM passengers;
```

> ねらい：`LIKE` の前後 `%`。スペースやピリオド位置でヒット数が変わることに注意。

**Q5. 家族サイズを作って確認**

```sql
SELECT PassengerId, (SibSp + Parch + 1) AS family_size
FROM passengers
WHERE (SibSp + Parch + 1) >= 5
ORDER BY family_size DESC, PassengerId;
```

> ねらい：`SELECT` 内で式を作る。`WHERE` でも同じ式を再利用。

> ✅ **KPIチェック①**：上の5本を**すべて実行**＋各1〜2行コメントを書いたらチェック。

---

# 4. LeetCode「今日やる20問」（SELECT/WHERE系）


# 5. 仕上げ（10分）— “代表パターンミニ集” をノート末尾に

1. **欠損比率**

   ```sql
   SELECT AVG(CASE WHEN col IS NULL THEN 1 ELSE 0 END) AS null_ratio FROM t;
   ```
2. **部分一致カウント**

   ```sql
   SELECT SUM(CASE WHEN name LIKE '%foo%' THEN 1 ELSE 0 END) FROM t;
   ```
3. **範囲＋集合**

   ```sql
   SELECT * FROM t WHERE x BETWEEN a AND b AND y IN ('A','B');
   ```
4. **上位N 抜き**

   ```sql
   SELECT * FROM t ORDER BY score DESC LIMIT 10;
   ```
5. **式でフィルタ**

   ```sql
   SELECT id, (a+b) AS s FROM t WHERE (a+b) > 5;
   ```
